<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>エリア判定ツール（PRO / RES）</title>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif; max-width:860px; margin:24px auto; padding:0 16px;}
    h1{font-size:22px; margin:0 0 10px;}
    .help{color:#555; font-size:14px; margin:0 0 14px; line-height:1.6;}
    label{display:block; margin:10px 0 6px; font-weight:700;}
    input{width:100%; padding:10px 12px; font-size:16px; border:1px solid #ccc; border-radius:10px;}
    .rowline{display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin-top:10px;}
    button{padding:10px 14px; font-size:16px; border-radius:10px; cursor:pointer;}
    .modebtn{border:1px solid #ccc; background:#fff;}
    .modebtn.active{border-color:#111; font-weight:800;}
    .card{margin-top:16px; padding:12px; border:1px solid #ddd; border-radius:12px;}
    .row{margin:6px 0;}
    .err{color:#b00020; font-weight:800;}
    code{background:#f6f8fa; padding:2px 6px; border-radius:6px;}
    .hr{height:1px; background:#eee; margin:10px 0;}
    details{border:1px dashed #ccc; border-radius:12px; padding:10px 12px; margin-top:14px;}
    summary{cursor:pointer; font-weight:700;}
    ul{margin:8px 0 0 18px;}
    .muted{color:#666; font-size:13px;}
  </style>
</head>

<body>
  <h1>エリア判定ツール（PRO / RES）</h1>
  <p class="help">
    入力形式：<code>35.88446158066726, 139.4528218383903</code>（緯度, 経度）<br/>
    出力：最も近い基準局所在地（都道府県名）＋距離（km）＋判定
  </p>

  <label for="coord">緯度, 経度</label>
  <input id="coord" placeholder='例: 35.88446158066726, 139.4528218383903' />

  <div class="rowline">
    <label style="margin:0; font-weight:700;">検索モード</label>

    <button id="modePRO" class="modebtn" type="button">PRO</button>
    <button id="modeRES" class="modebtn" type="button">RES</button>
    <button id="modeBOTH" class="modebtn" type="button">PRO/RES 両方</button>

  </div>

  <details>
    <summary>判定基準（注意書き）</summary>
    <ul>
      <li><b>PRO</b>：◎（30km未満）／〇（30km以上、40km未満）／要現地調査（40km以上、50km未満）／非推奨（50km以上）</li>
      <li><b>RES</b>：◎（40km未満）／〇（40km以上、50km未満）／要現地調査（50km以上、60km未満）／非推奨（60km以上）</li>
    </ul>
  </details>

  <div id="out" class="card" style="display:none;"></div>

  <script>
    // =========================
    // PRO/RES 設定
    // =========================
    const CONFIG = {
      PRO: {
        pointsFile: "./PROpoints.json",
        judge: (km) => {
          if (km < 30) return "◎（30km未満）";
          if (km < 40) return "〇（30km以上、40km未満）";
          if (km < 50) return "要現地調査（40km以上、50km未満）";
          return "非推奨（50km以上）";
        }
      },
      RES: {
        pointsFile: "./RESpoints.json",
        judge: (km) => {
          if (km < 40) return "◎（40km未満）";
          if (km < 50) return "〇（40km以上、50km未満）";
          if (km < 60) return "要現地調査（50km以上、60km未満）";
          return "非推奨（60km以上）";
        }
      }
    };

    // ===== Core geo =====
    const R = 6371000; // meters
    const toRad = (deg) => deg * Math.PI / 180;

    function haversineMeters(lat1, lng1, lat2, lng2) {
      const φ1 = toRad(lat1), φ2 = toRad(lat2);
      const dφ = toRad(lat2 - lat1);
      const dλ = toRad(lng2 - lng1);
      const a = Math.sin(dφ/2)**2 + Math.cos(φ1) * Math.cos(φ2) * Math.sin(dλ/2)**2;
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return R * c;
    }

    function parseLatLngLine(s) {
      if (!s) return { lat: null, lng: null, error: "入力が空です" };
      const parts = String(s).trim().split(",");
      if (parts.length !== 2) return { lat: null, lng: null, error: "形式は「緯度, 経度」です（カンマ区切り）" };

      const lat = Number(parts[0].trim());
      const lng = Number(parts[1].trim());
      if (!Number.isFinite(lat) || !Number.isFinite(lng)) return { lat: null, lng: null, error: "緯度経度は数値で入力してください" };
      if (lat < -90 || lat > 90) return { lat: null, lng: null, error: "緯度は -90〜90 です" };
      if (lng < -180 || lng > 180) return { lat: null, lng: null, error: "経度は -180〜180 です" };
      return { lat, lng, error: null };
    }

    // ===== Data loading (cached) =====
    const pointsCache = { PRO: null, RES: null };

    async function loadPoints(which) {
      if (pointsCache[which]) return pointsCache[which];

      const res = await fetch(CONFIG[which].pointsFile, { cache: "no-store" });
      if (!res.ok) throw new Error(`${which}: 候補点ファイルが読み込めませんでした`);
      const pts = await res.json();
      if (!Array.isArray(pts) || pts.length === 0) throw new Error(`${which}: 候補点が空です`);
      pointsCache[which] = pts;
      return pts;
    }

    async function findNearest(which, lat, lng) {
      const points = await loadPoints(which);

      let best = null;
      for (const p of points) {
        if (typeof p.lat !== "number" || typeof p.lng !== "number") continue;
        const d = haversineMeters(lat, lng, p.lat, p.lng);
        if (!best || d < best.distance_m) best = { point: p, distance_m: d };
      }
      if (!best) throw new Error(`${which}: 有効な候補点がありません`);
      return best;
    }

    function displayName(point) {
      // PRO/RES ともに pref が入っていれば都道府県名になる
      return point.name ?? point.pref ?? point.id ?? "(no name)";
    }

    function renderBlock(which, name, km, verdictText) {
      return `
        <div class="row"><b>${which} 最近接点:</b> ${name}</div>
        <div class="row"><b>${which} 距離:</b> ${km.toFixed(3)} km</div>
        <div class="row"><b>${which} 判定:</b> ${verdictText}</div>
      `;
    }

    // ===== UI =====
    const out = document.getElementById("out");
    const input = document.getElementById("coord");

    const btnModePRO  = document.getElementById("modePRO");
    const btnModeRES  = document.getElementById("modeRES");
    const btnModeBOTH = document.getElementById("modeBOTH");

    let currentMode = "BOTH"; // 初期値（表示上の初期選択）

    function setMode(m, autoRun = true) {
      currentMode = m;

      btnModePRO.classList.toggle("active", m === "PRO");
      btnModeRES.classList.toggle("active", m === "RES");
      btnModeBOTH.classList.toggle("active", m === "BOTH");

      if (autoRun) run();
    }

    btnModePRO.addEventListener("click", () => setMode("PRO", true));
    btnModeRES.addEventListener("click", () => setMode("RES", true));
    btnModeBOTH.addEventListener("click", () => setMode("BOTH", true));

    // 初期は選択状態だけ付けて、勝手に検索はしない
    setMode("BOTH", false);

    async function run() {
      out.style.display = "block";
      out.innerHTML = "計算中…";

      const parsed = parseLatLngLine(input.value);
      if (parsed.error) {
        out.innerHTML = `<div class="err">${parsed.error}</div>`;
        return;
      }

      const m = currentMode;

      try {
        if (m === "PRO") {
          const r = await findNearest("PRO", parsed.lat, parsed.lng);
          const km = r.distance_m / 1000;
          out.innerHTML = renderBlock("PRO", displayName(r.point), km, CONFIG.PRO.judge(km));
          return;
        }

        if (m === "RES") {
          const r = await findNearest("RES", parsed.lat, parsed.lng);
          const km = r.distance_m / 1000;
          out.innerHTML = renderBlock("RES", displayName(r.point), km, CONFIG.RES.judge(km));
          return;
        }

        // BOTH
        const [p, r] = await Promise.all([
          findNearest("PRO", parsed.lat, parsed.lng),
          findNearest("RES", parsed.lat, parsed.lng),
        ]);

        const kmP = p.distance_m / 1000;
        const kmR = r.distance_m / 1000;

        out.innerHTML = `
          ${renderBlock("PRO", displayName(p.point), kmP, CONFIG.PRO.judge(kmP))}
          <div class="hr"></div>
          ${renderBlock("RES", displayName(r.point), kmR, CONFIG.RES.judge(kmR))}
        `;
      } catch (e) {
        out.innerHTML = `<div class="err">${e.message}</div>`;
      }
    }

    // Enterでも検索
    input.addEventListener("keydown", (ev) => { if (ev.key === "Enter") run(); });
  </script>
</body>
</html>
